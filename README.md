# Exceptions and Exception handlers

В данной статье мы поговорим об исключениях и их обработке, рассмотрим какие варианты нам доступны в Spring,
разберем какие проблемы с ними связаны, а также посмотрим на варианты которые помогут облегчить нам жизнь.

Исключения можно делить на группы, пробовать их классифицировать. Нас как людей практических это мало интересует,
а интересует нас следующее: исключения пораждаются системой и ею же обрабатываются.

Перед тем как вести какие либо рассуждения предлагаю немного погрузиться в структуру проекта и
познакомиться с моделью исключений.






<изображение иерархии исключений (см. в asset)>


Также зачастую для rest результатом обработки исключения является некоторое DTO
в нашем случае это `ExceptionDto`


## Как пораждаются исключения?

1. `throw new ...Exception`
2. Фабрика исключений

Имеет ли это вообще смысл?

## Классичесий REST

Для начала давайте определимся какие в целом механизмы Spring MVC нам доступны


### @ExceptionHandler в контроллере


### @ControllerAdvice/@RestControllerAdvice

При наличии нескольких обработчиков в различных ControllerAdvice классах и отсутствии @Order порядок поиска
ExceptionHandler не определен

### @Order для контроля порядка поиска ExceptionHandler метода

Для оценки данного решения необходимо раскоментировать Order для классов `BaseExceptionHandler` и `UserExceptionHandler`

### Custom ExceptionHandlerResolver для поиска ExceptionHandler независимо от Order

Для оценки данного решения необходимо раскоментировать Configuration для классов `ExtendedWebMvcConfigurationSupport`

### Кейсы

Все кейсы подтверждаются тестами в проекте

1. Исключение прошедшее через контроллер с двумя обработчиками (в контроллере и в ControllerAdvice) обрабатываются
   контроллером - **PASS**
2. При наличии нескольких обработчиков в одном ControllerAdvice классе, вызывается обработчик
   для класса наиболее близкого по иерархии. Сначала вызываются частные обработчики, потом общие - **PASS**
3. При наличии нескольких обработчиков в разных ControllerAdvice классах, вызывается обработчик
   для класса наиболее близкого по иерархии. Сначала вызываются частные обработчики, потом общие - **FAIL.**
   Этому есть подтверждение в документации "It is undefined what order controller-advices are processed" [2]
   1. Проблему возможно частично решить используя `@Order`. В текущем проекте проблему можно воспроизвести
      убрав аннотацию `@Order` для `BaseExceptionHandler` и `UserExceptionHandler` и запустив тест 
      `OrderControllerTest#undefinedBehaviourForDifferentControllerAdvice`. **Наименее инвазивный вариант
      для Spring**
   2. Второй вариант решения проблемы представлен в классе `AdvancedExceptionHandlerExceptionResolver`.
      В данном случае после выбора ControllerAdvice класса с методом выполняется дополнительная логика
      по определению какой из найденных ExceptionHandler методов ближе классу исключения
      (логика параметров аннотации @ControllerAdvice не нарушена). **Инвазивный вариант, так как 
      требуется переопределение логики базового Spring класса, с копированием/правкой приватных методов
      базовго класса, определении конфигурации.** Но такой вариант не требует указания `@Order` и всегда
      выбирает более специфичную версию метода
4. Убедиться в возможности повторной обработки исключения в ControllerAdvice классе, при условии что в 
   контроллере имеется обработчик, который вызвался и в котором исключение было брошено повторнор - **FAIL**.
   Это собственно видно из реализации класса `ExceptionHandlerExceptionResolver`




Re-throw exceptions from controller


## Reactive MVC?

На первый взгляд все сильно отличается от классического подхода


## Литература

1. [Обработка исключений в контроллерах Spring](https://habr.com/en/articles/528116/)
2. [Exception Handling in Spring MVC](https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc)